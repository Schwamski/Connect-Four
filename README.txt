Before using the program, you must have node.js installed.


To interact with the program, the player must edit the Referee.re file to reflect the two players that will play the game: either a human player vs. human player, human vs. AI player, AI vs human player, or AI vs AI player. This is done by changing the contents of line 56 in the Referee file in the wrapper: Referee(Connect4, HumanPlayer(Connect4), AIPlayer(Connect4)). The ‘HumanPlayer’ and ‘AIPlayer’ can each be swapped to reflect the players that will participate in the game. The user can then input ‘npm install’ followed by ‘npm run build’ in the terminal to compile the code and verify that there are no unresolved bugs. You may also need to run 'npm install readline-sync' before running the program for the first time. The user then inputs ‘node src/referee.bs.js’ into the terminal, and the game begins. The game board is printed into the terminal and each player is prompted to move. If the player is an AI player, they automatically populate a move. If the player is a human player, they must input a legal move and press enter. The program updates the game board after each player makes a move, reprinting the game board into the terminal and continuously prompting the next player to make a move. The game continues until the game state becomes State(Win(_), _) or State(Draw, _). This pattern holds true for any combination of two human or AI players. In the case of two AI players, there is little time between each move that an AI makes, so the terminal rapidly prints game boards, and a conclusion is reached fairly quickly. In the case of two human players, the terminal will prompt each player one at a time to input a move, indicating the current state of the board and which player’s turn it is each time. In the human vs AI or AI vs human games, the AI automatically makes moves, but the human player is manually prompted to input a move.
	In this game in particular, Connect 4 is being played. Thus, each player makes a move by inputting an integer between 1 and n, where n is the number of columns in the gameboard (which may be of arbitrary size). The program will prompt you to try a different move if you input an illegal move: that is, your move must be an integer value between 1 and n, and you cannot input an integer value of a column that is already full of chips. The game continues this way until a player achieves four tokens in a row, or the game ends in a draw. A draw is reached when the game board is completely full, yet neither player has achieved a four in row. 

The overall program is orchestrated by the Referee, which takes in a move from a player, updates the game state, returns the updated state, and then prompts the next player for another move. The meat of the program, however, is contained within the process of taking in a move and using that move to produce an updated state. First, the moveOfString procedure takes in the player’s move, inputted as a string, and produces a move. This procedure tests to ensure that the player’s inputted move is legal. The nextState procedure then takes the previous game state, and the player’s move to produce an updated game state. The nextState procedure works by adding adding the player’s chip to the column they designated, and then running the checkWinner procedure to see if the player won the game by making that move. If the checkWinner procedure returns true, the state is updated to a win state. If the checkWinner procedure returns false, the boardSpaceQ procedure is prompted. This procedure checks to see if any legal moves remain. If no legal moves remain, the game state is updated to a draw state. If legal moves do remain, the state is updated to an ongoing game state for the opposing player, including the updated board. Each time the state is updated, the state is printed using the stringOfState procedure, which includes the game board and status of the game. Of note, the game begins by producing the initial state, which is an empty board and P1’s turn.

The AI player heavily depends on the estimateValue procedure, which quantifies how much the current game board favors P1 vs P2. The estimateValue procedure looks at potential 4 in a rows, counting +2 for when P1 has 2 of the 4 chips in a potential four in a row, or +7 for when P1 has 3 of the 4 chips in a potential four in a row. Further, controlled columns are worth +12. The values are negative and equal in magnitude for P2.

The AI player file functions just like a human player: it intakes the game state and outputs a move. The AI player functions by creating a list of all legalMoves and determining the state that would be produced by each of these moves. The miniMax algorithm is run on each of these possible game states, which uses the estimateValue procedure and then assigns a float value to each game state representing how much that state favors P1 vs P2. This is similar to estimateValue but fundamentally different: whereas estimateValue looks at the current gameState to quantify the value of the game board, miniMax uses future outcomes of the game (at some depth, n) to recursively populate the value of the game board, operating under the assumption that both players will choose moves that benefit themselves. The AI player runs a procedure like argMax using the list of legal moves and the miniMax algorithm to see which move from the list of legal moves returns the optimal value when miniMax is applied. For P1, the optimal value is the maximum, and for P2, the optimal value is the minimum. Thus, the AI determines the optimal move to make, and produces this move as an output.
